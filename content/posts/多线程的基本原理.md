---
title: "多线程的基本原理"
date: 2019-12-23T15:29:42+08:00
draft: false
---

### 为什么要使用多线程？    
CPU的速度是非常快的，例如一个3GHz的CPU做一件事的时间是0.3ns，但是内存的读取速度大概在100ns，磁盘读取的速度更是慢到10ms。这就意味着CPU在读取内存或硬盘的这段时间只能等待，浪费了太多时间，可参考[让 CPU 告诉你硬盘和网络到底有多慢](https://cizixs.com/2017/01/03/how-slow-is-disk-and-network/)。   

默认情况下，我们执行的程序只有一个线程，这让处理问题非常自然，但是却有严重的性能问题，因为Java执行模型是同步/阻塞的，只有在执行完一行代码后才能执行下一行代码，遇上I/O等速度慢的操作，CPU的效率将大打折扣。

解决的方法便是使用多线程，让CPU用等待的时间去做其他的事，尽可能提升CPU的效率。  

多线程带来的性能提升，对于IO密集型应用极有作用，包括网络IO(通常包括数据库)、文件IO；而对于CPU密集型应用的作用作用就不那么明显了。   

性能提升的上限： 单核CPU 100%  ， 多核CPU N*100%  



#### 使用Thread时应注意     
    Java中只有这么一种方法代表线程      
    使用start()方法才能并发执行       
    每多开一个线程，就多一个执行流      
    每个方法栈(局部变量)是线程私有的            
    静态变量/类变量是被所有线程共享的           


### 多线程带来的问题及解决方法    
>线程难的本质原因是你要看着同一份代码，想象不同的人在疯狂地以乱序执行它。     

多个线程访问共享变量，由于访问是乱序的，如果对共享变量的操作不是原子的，就可能会导致得到错误的结果。    
例如： i++这件事不是一个原子操作，它有三个操作：    
``取i的值``    
`把i的值加一`    
`把修改后的值写回i`   
如果当某个线程执行到把i的值加一还没来得及写回i，分配的时间片就用完了，CPU转而执行其他线程时取的i的值还是原先的值，这也就意味着i++操作执行了两次但i实际上只加了一次，于是导致最终结果出错。      

这种多个线程对同一个对象中的同一个实例变量进行操作时出现的值被更改、值不同步的情况，进而影响程序的执行流程的行为称为非线程安全。    

解决线程非安全的办法是在某个方法前加上`synchronized`关键字修饰，使多个线程在执行此方法时，以排队的方式进行处理。当一个线程调用此方法前，先判断这个方法有没有被上锁，如果上锁，说明有其他线程正在调用这个方法，必须等其他线程对这个方法调用结束后才可以执行这个方法。这样也就实现了排队调用这个方法的目的，达到了按顺序对 count 变量减 1 的效果。synchronized 可以在任意对象及方法上加锁，而加锁的这段代码称为“互斥区” 或“临界区”。

```
    synchronized  public void method()
    { 
        count--; 
        //do something else
    }
```
synchronized 不仅可以用到同步方法，也可以用到同步块。对于同步块，synchronized 获取的是参数中的对象锁。
```
public void method()
{
    Object obj=new Object();
    synchronized(obj)
    {
        count--;
        //do something else
    }
}
```

当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果能够拿到锁，那么这个线程就可以执行 synchronize 里面的代码。如果不能拿到锁，那么这个线程就会不断地尝试拿锁，直到能够拿到为止，而且有多个线程同时去争抢这把锁。   

### 线程的生命周期
包括7种状态，分别是出生状态、就绪状态、运行状态、等待状态、休眠状态、阻塞状态和死亡状态。     
![](线程生命周期.jpg)

下面对线程生命周期中的7种状态做说明     
1.出生状态：用户在创建线程时所处的状态，在用户使用线程实例调用start()方法之前，线程都处于出生状态。          
2.就绪状态：也称可执行状态，当用户调用start()方法之后，线程处于就绪状态。       
3.运行状态：当线程得到系统资源后进入运行状态。      
4.等待状态：当处于运行状态下的线程调用Thread类的wait()方法时，该线程就会进入等待状态。进入等待状态的线程必须调用Thread类的notify()方法才能被唤醒。notifyAll()方法是将所有处于等待状态下的线程唤醒。     
5.休眠状态：当线程调用Thread类中的sleep()方法时，则会进入休眠状态。     
6.阻塞状态：如果一个线程在运行状态下发出输入/输出请求，该线程将进入阻塞状态，在其等待输入/输出结束时，该线程进入就绪状态。对阻塞的线程来说，即使系统资源关闭，线程依然不能回到运行状态。        
7.死亡状态：当线程run()方法执行完毕，线程进入死亡状态。     

